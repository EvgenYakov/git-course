// У деревенских ворон есть старый скальпель, который они иногда используют время 
// для специальных целей - например, чтобы прорезать двери или что-то
// упаковать. Чтобы можно было быстро найти скальпель каждый раз, когда
// его перемещают в другое гнездо, в хранилище того гнезда, откуда его взяли,
// и гнезда, его забравшего, добавляется запись под названием "scalpel ", 
// значением которой является информация о новом местоположении скальпеля.
// Таким образом, чтобы найти скальпель, нужно проследить ряд записей
// в хранилищах, пока не будет найдено гнездо, хранящее указание на то гнездо,
// где в данный момент находится скальпель.
// Напишите асинхронную функцию locateScalpel, которая это делает, начиная с 
// того гнезда, в котором она выполняется. Для доступа к хранилищу
// в произвольном гнезде можете использовать определенную ранее функцию
// anyStorage. Скальпель передается между гнездами достаточно давно; 
// возможно, в хранилище каждого гнезда есть запись "scalpel ".
// Затем напишите такую же функцию, не используя async и await.
// Правильно ли сбои запроса отображают отклонения возвращенного промиса
// в обеих версиях? Как именно это реализовано? 

// Проверял тут ---> https://eloquentjavascript.net/code/#11.1

function locateScalpel(nest) {
    function findScalpel(next) {
        return anyStorage(nest, next, 'scalpel')
            .then(x => {
                if (x == next) {
                    return x;
                } else {
                    return findScalpel(x);
                }
            });
    }
    return findScalpel(nest.name);
}
locateScalpel(bigOak).then(console.log);